# Часть 18. Роли и разрешения (IV) | Управление ролями субадминистраторов

В этой части мы расширим роли и разрешения для субадминистраторов, создав специальную таблицу admins_roles и форму обновления ролей и разрешений на панели администратора.

Эта функция позволит главному администратору предоставлять или отзывать доступ к различным модулям, таким как категории, продукты, страницы CMS и т.д.

Администраторы теперь могут динамически назначать права просмотра, редактирования или полного доступа субадминистраторам для различных модулей. Давайте разберёмся!

## Шаг 1. Создайте таблицу ```admins_roles```

Начнем с создания новой таблицы для хранения разрешений субадминистратора.

Запустите команду миграции:
```
php artisan make:migration create_admins_roles_table
```
Определите схему в файле миграции:
```php
Schema::create('admins_roles', function (Blueprint $table) {
    $table->id();
    $table->integer('subadmin_id'); // Идентификатор субадминистратора
    $table->string('module'); // Имя модуля (категории, продукты и т.д.)
    $table->tinyInteger('view_access'); // Доступ только для просмотра
    $table->tinyInteger('edit_access'); // Доступ для просмотра и редактирования
    $table->tinyInteger('full_access'); // Полный доступ (просмотр, редактирование, удаление)
    $table->timestamps();
});
```
Запустите миграцию для создания таблицы:
```
php artisan migrate
```
## Шаг 2. Создайте модель роли администратора

Для создания модели выполните следующую команду:
```
php artisan make:model AdminsRole
```
## Шаг 3. Обновите ```subadmins.blade.php``` — добавьте ссылку «Обновить роль».

Добавляем ссылку «Обновить роль» в список субадминистраторов для управления разрешениями:
```html
<a title="Set Permissions for Subadmin" class="ms-2"
   href="{{ url('admin/update-role/' . $subadmin->id) }}"><i class="fas fa-unlock"></i></a>
```
## Шаг 4. Определить маршруты в ```web.php```

Мы создаем маршруты ```GET``` и ```POST``` для обновления ролей и разрешений.
```php
Route::get('/update-role/{id}', [AdminController::class, 'updateRole']);
Route::post('/update-role/request', [AdminController::class, 'updateRoleRequest']);
```
## Шаг 5. Создайте функции ```updateRole``` и ```updateRoleRequest``` в ```AdminController```

```updateRole()``` — функция отображение формы обновления роли субадминистратора
```php
public function updateRole($id)
{
    $subadminRoles = AdminsRole::where('subadmin_id', $id)->get()->toArray();
    $subadminDetails = Admin::where('id', $id)->first()->toArray();
    $title = "Update " . $subadminDetails['name'] . " Subadmin Roles/Permissions";
    return view('admin.subadmins.update_roles')->with(compact('title', 'id', 'subadminRoles'));
}
```
```updateRoleRequest()``` — функция обработки отправки формы
```php
public function updateRoleRequest(Request $request)
{
    if ($request->isMethod('post')) {
        $data = $request->all();
        $result = $this->adminService->updateRole($data);
        return redirect()->back()->with('success_message', $result['message']);
    }
}
```
## Шаг 6. Создайте ```update_roles.blade.php``` (форма управления ролями субадминистратора)
Создайте файл ```update_roles.blade.php``` в папке ```resources/views/admin/subadmins/``` для отображения формы ролей и разрешений.

Мы разрабатываем форму, с помощью которой администратор может динамически назначать или отзывать доступ к модулям.

Пример: управление доступом к модулю «Категории»
```html
<form name="subadminForm" id="subadminForm" method="post"
      action="{{ url('admin/update-role/request') }}">
    @csrf
    <input type="hidden" name="subadmin_id" value="{{ $id }}">
    @if(!empty($subadminRoles))
        @foreach($subadminRoles as $role)
            @if($role['module'] == 'categories')
                @php
                    $viewCategories = $role['view_access'] == 1 ? 'checked' : '';
                    $editCategories = $role['edit_access'] == 1 ? 'checked' : '';
                    $fullCategories = $role['full_access'] == 1 ? 'checked' : '';
                @endphp
            @endif
        @endforeach
    @endif
    <!--begin::Body-->
    <div class="card-body">
        <div class="form-group col-md-12">
            <label for="categories">Categories:</label>
            <input type="checkbox" name="categories[view]" value="1" {{ $viewCategories ?? '' }}>
            <input type="checkbox" name="categories[edit]" value="1" {{ $editCategories ?? '' }}>
            <input type="checkbox" name="categories[full]" value="1" {{ $fullCategories ?? '' }}>
        </div>
    </div>
    <!--end::Body-->
    <!--begin::Footer-->
    <div class="card-footer">
        <button type="submit" class="btn btn-primary">Submit</button>
    </div>
    <!--end::Footer-->
</form>
```
Это можно распространить и на другие модули (продукты, страницы CMS и т. д.).
## Шаг 7. Функция ```updateRole()``` в ```AdminService```
Эта функция динамически обновляет роли и разрешения субадминистратора.
```php
public function updateRole($request): array
{
    $data = $request->all();
    // Remove existing roles before updating
    AdminsRole::where('subadmin_id', $data['subadmin_id'])->delete();
    // Assign new roles dynamically
    foreach ($data as $key => $value) {
        if (!is_array($value)) continue; // Skip non-module fields
        $view = $value['view'] ?? 0;
        $edit = $value['edit'] ?? 0;
        $full = $value['full'] ?? 0;
        AdminsRole::insert([
            'subadmin_id' => $data['subadmin_id'],
            'module' => $key,
            'view_access' => $view,
            'edit_access' => $edit,
            'full_access' => $full,
        ]);
    }
    return ['message' => "Subadmin Roles updated successfully!"];
}
```
## Шаг 8. Динамическое управление ролями и разрешениями субадминистратора
Теперь мы улучшим систему управления ролями субадминистратора, сделав форму полностью динамической. Это позволит администратору управлять правами доступа к различным модулям, таким как категории, товары, заказы, пользователи и т. д., без необходимости их жёсткого кодирования.

Создание полностью динамической формы с помощью массива модулей:

Передайте массив модулей ($modules) из контроллера:
```php
$modules = ['categories', 'products', 'orders', 'users'];
return view('admin.subadmins.update_roles')->with(compact('modules', 'subadminRoles', 'id', 'title'));
```
Пройдитесь циклом по каждому модулю и динамически проверьте разрешения.

Нет необходимости жестко кодировать модули, такие как категории, продукты и т. д.

### Обновление функции ```updateRole``` в ```AdminController```

Измените функцию для обновления динамических модулей:
```php
public function updateRole($id)
{
    $subadminRoles = AdminsRole::where('subadmin_id', $id)->get()->toArray();
    $subadminDetails = Admin::where('id', $id)->first()->toArray();
    $modules = ['categories', 'products', 'orders', 'users', 'cms_pages']; // Dynamic Modules
    $title = "Manage Subadmin (" . $subadminDetails['name'] . ") Roles/Permissions";
    return view('admin.subadmins.update_roles')->with(compact('modules', 'subadminRoles', 'id', 'title'));
}
```
Обновление ```update_roles.blade.php``` (шаблон Blade)

Измените шаблон Blade для циклического прохождения динамических модулей:
```html
<form name="subadminForm" id="subadminForm" method="post"
      action="{{ url('admin/update-role/request') }}">
    @csrf
    <input type="hidden" name="subadmin_id" value="{{ $id }}">
    <div class="card shadow-sm">
        <!--begin::Body-->
        <div class="card-body">
            @foreach($modules as $module)
                @php
                // Fetch permissions for the current module
                $viewAccess = $editAccess = $fullAccess = '';
                foreach ($subadminRoles as $role) {
                    if ($role['module'] == $module) {
                        $viewAccess = $role['view_access'] == 1 ? 'checked' : '';
                        $editAccess = $role['edit_access'] == 1 ? 'checked' : '';
                        $fullAccess = $role['full_access'] == 1 ? 'checked' : '';
                        break;
                    }
                }
                @endphp
                <div class="form-group mb-3">
                    <label class="me-2"><strong>{{ ucwords(str_replace('_',' ', $module)) }}: </strong></label>
                    <div class="form-check form-check-inline">
                        <input class="form-check-input" type="checkbox" name="{{ $module }}[view]" value="1" {{ $viewAccess }}>
                        <label class="form-check-label">View Access</label>
                    </div>
                    <div class="form-check form-check-inline">
                        <input class="form-check-input" type="checkbox" name="{{ $module }}[edit]" value="1" {{ $editAccess }}>
                        <label class="form-check-label">View/Edit Access</label>
                    </div>
                    <div class="form-check form-check-inline">
                        <input class="form-check-input" type="checkbox" name="{{ $module }}[full]" value="1" {{ $fullAccess }}>
                        <label class="form-check-label">Full Access</label>
                    </div>
                </div>
                <hr>
            @endforeach
        </div>
        <!--end::Body-->
        <!--begin::Footer-->
        <div class="card-footer text-end">
            <button type="submit" class="btn btn-primary">
                <i class="fas fa-save me-2"></i> Save Changes
            </button>
        </div>
        <!--end::Footer-->
    </div>
</form>
```
Мы протестируем этот модуль ролей и разрешений при работе с категориями, продуктами, страницами CMS и другими модулями.
# Что дальше?
В [следующей части](19.md) мы продолжим совершенствовать модуль «Роли и разрешения», интегрируя его с категориями, продуктами, страницами CMS и другими функциями.

[Оглавление](../README.md)
