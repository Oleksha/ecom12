# Часть 36. Галерея изображений продукта | Загрузите несколько изображений через Dropzone
В этой части мы реализуем галерею изображений товаров с поддержкой загрузки нескольких изображений через Dropzone. Эта функция улучшает презентацию товаров и удобство администрирования.
## Шаг 1. Создайте таблицу products_images
Создание модели и миграция: 
```
php artisan make:model ProductsImage -m
```
Добавьте необходимые столбцы: 
```
id, product_id, image, sort, status, timestamps
```
Использовать внешний ключ с каскадным удалением для ```product_id```
```php
Schema::create('products_images', function (Blueprint $table) {
    $table->id();
    $table->foreignId('product_id')->constrained('products')->onDelete('cascade');
    $table->string('image');
    $table->integer('sort')->default(0);
    $table->tinyInteger('status')->default(1);
    $table->timestamps();
});
```
Запустите миграцию:
```
php artisan migrate
```
## Шаг 2. Обновить модель ProductsImage
```php
protected $fillable = ['product_id', 'image', 'sort', 'status'];
```
## Шаг 3. Обновить add_edit_product.blade.php
- Добавить загрузчик Dropzone для альтернативных изображений продукта.
- Показывать предварительный просмотр изображений с возможностью удаления.
- Включить скрытый вход для сбора имен файлов загруженных изображений.
```html
<div class="mb-3">
    <label class="form-label" for="product_images_dropzone">
        Alternate Product Images (Multiple Uploads Allowed, Max 500 KB each)
    </label>
    <div class="dropzone" id="productImagesDropzone"></div>

    @if(isset($product->product_images) && $product->product_images->count() > 0)
        @foreach($product->product_images as $img)
            <div style="display: inline-block; position: relative; margin: 5px;">
                <a target="_blank"
                   href="{{ url('front/images/products/' . $img->image) }}">
                    <img src="{{ asset('front/images/products/' . $img->image) }}"
                         style="width: 50px" alt="">
                </a>
                <a href="javascript:void(0)" class="confirmDelete"
                   data-module="product-image" data-id="{{ $img->id }}"
                   data-image="{{ $img->image }}">
                    <i class="fas fa-trash"
                       style="position: absolute; top: 0; right: 0; color: red;"></i>
                </a>
            </div>
        @endforeach
    @endif

    <!-- Hidden input to collect alternate images -->
    <input type="hidden" name="product_images" id="product_images_hidden">
</div>
```
## Шаг 4. Обновите scripts.blade.php
Интегрируйте логику Dropzone.js для:
- Загрузка изображений
- Предварительный просмотр
- Удаление файлов из временной папки и скрытый ввод
```js
// Product Images Dropzone
let productImagesDropzone = new Dropzone('#productImagesDropzone', {
    url: "{{ route('product.upload.images') }}",
    maxFiles: 10,
    acceptedFiles: "image/*",
    parallelUploads: 10, // Add this line to allow parallel uploads
    uploadMultiple: false, // Keep this false unless you want to send all files in one request
    maxFilesize: 0.5,
    addRemoveLinks: true,
    dictDefaultMessage: 'Drag & drop product images or click to upload',
    headers: {
        'X-CSRF-TOKEN': "{{ csrf_token() }}"
    },
    init: function () {
        this.on('success', function (file, response) {
            // Append filename to hidden input
            let hiddenInput = document.getElementById('product_images_hidden');
            let currentValue = hiddenInput.value;

            if (currentValue === '') {
                hiddenInput.value = response.fileName;
            } else {
                hiddenInput.value = currentValue + ',' + response.fileName;
            }

            file.uploadedFileName = response.fileName;
        });

        this.on('removedfile', function (file) {
            if (file.uploadedFileName) {
                let hiddenInput = document.getElementById('product_images_hidden');
                let currentValue = hiddenInput.value;
                let files = currentValue.split(',');

                files = files.filter(name => name !== file.uploadedFileName);
                hiddenInput.value = files.join(',');

                // Optional: Delete the file from server
                $.ajax({
                    url: "{{ route('product.delete.temp.image') }}",
                    type: "POST",
                    data: { filename: file.uploadedFileName },
                    headers: {
                        'X-CSRF-TOKEN': "{{ csrf_token() }}"
                    }
                });
            }
        });
    }
});
```
## Шаг 5. Определите маршруты в web.php
```php
Route::post('product/upload-images', [ProductController::class, 'uploadImages'])->name('product.upload.images');
Route::post('product/delete-temp-image', [ProductController::class, 'deleteTempImage'])->name('product.delete.temp.image');
Route::get('delete-product-image/{id?}', [ProductController::class, 'deleteProductImage']);
```
## Шаг 6. Обновите ProductController
Добавьте логику для обработки:
- Загрузка изображения
- Удаление временного изображения
- Постоянное удаление
- Редактирование продукта с использованием изображения
```php
public function uploadImages(Request $request)
{
    if ($request->hasFile('file')) {
        $fileName = $this->productService->handleImageUpload($request->file('file'));
        return response()->json(['fileName' => $fileName]);
    }
    $file = $request->file('file');
    // Move to temp directory
    $file->move(public_path('temp'), $filename);
    return response()->json([
        'fileName' => $filename,
        'success' => true
    ]);
}

public function deleteProductImage(string $id)
{
    $message = $this->productService->deleteProductImage($id);
    return redirect()->back()->with('success_message', $message);
}
```
Также обновите функцию редактирования, чтобы добавить связь product_images:
```php
public function edit(string $id)
{
    $title = "Edit Product";
    $product = Product::with('product_images')->findOrFail($id);
    $getCategories = Category::getCategories('Admin');
    return view('admin.products.add_edit_product', compact('title', 'product', 'getCategories'));
}
```
## Шаг 7. Обновить модель Product
Добавьте отношение hasMany между таблицами products и product_images:
```php
public function product_images(): HasMany
{
    return $this->hasMany(ProductsImage::class);
}
```
## Шаг 8. Обновите службу продукта
Обновите addEditProduct() до:
- Обработать основное изображение
- Обработка видео о продукте
- Сохраняйте альтернативные изображения из Dropzone.
- Использовать временную папку для хранения изображений
- Копировать изображения в постоянное место и создавать записи в базе данных в products_images.
```php
public function addEditProduct(Request $request): string
{
    $data = $request->all();

    // ... Код без изменений ... //

    $product->save();

    // Upload Alternate Images
    if (!empty($data['product_images'])) {
        // Ensure we have an array
        $imageFiles = is_array($data['product_images'])
            ? $data['product_images']
            : explode(',', $data['product_images']);

        // Remove any empty values
        $imageFiles = array_filter($imageFiles);

        foreach ($imageFiles as $index => $filename) {
            $sourcePath = public_path('temp/' . $filename);
            $destinationPath = public_path('front/images/products/' . $filename);

            if (file_exists($sourcePath)) {
                @copy($sourcePath, $destinationPath);
                @unlink($sourcePath);
            }
            
            ProductsImage::create([
                'product_id' => $product->id,
                'image' => $filename,
                'sort' => $index,
                'status' => 1,
            ]);
        }
    }
```
Окончательный результат:
- Администратор может загружать и удалять несколько альтернативных изображений продукта через Dropzone.
- Изображения перемещаются из временного в постоянное место хранения.
- Изображения перечислены и могут быть удалены на странице «Редактировать продукт».
# Что дальше?
В [следующей части](37.md) мы начнем работать над атрибутами продукта, где вы сможете определять размеры для каждого продукта с его артикулом, запасами и ценой.

[Оглавление](../README.md)
