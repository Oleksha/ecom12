# Часть 43. Изменение порядка столбцов в DataTable | Перемещение/изменение порядка столбцов
В этой части мы добавляем в панель администратора расширенную функцию, которая позволяет каждому администратору настраивать и сохранять порядок столбцов в таблицах данных (категории и товары) с помощью ColReorder, AJAX и бэкенд-логики Laravel. Эти настройки хранятся в базе данных и каждый раз перезагружаются, обеспечивая персонализированный интерфейс для каждого администратора.

**Что вы узнаете в этой части**:
- Как использовать DataTables с ColReorder
- Сохраните настройки порядка столбцов в таблице column_preferences.
- Сохранение порядка столбцов с помощью AJAX-запросов
- Извлечь сохраненный заказ и применить его при рендеринге таблиц
- Улучшите пользовательский опыт, позволив администраторам управлять своим представлением
- Лучшие практики разделения логики для нескольких таблиц (категорий/товаров)
## Шаг 1. Миграция: создание таблицы column_preferences
В этой таблице хранятся настройки порядка столбцов для каждого администратора и каждой таблицы (например, продукты или категории), сохраненные в формате JSON. Сформируем файл миграции с помощью команды:
```
php artisan make:migration create_column_preferences_table
```
Изменим его в соответствии с кодом ниже
```php
public function up(): void
{
    Schema::create('column_preferences', function (Blueprint $table) {
        $table->id();
        $table->unsignedBigInteger('admin_id');
        $table->string('table_name');
        $table->text('column_order'); // в формате JSON
        $table->timestamps();
    });
}
```
И сформируем таблицу командой
```
php artisan migrate
```
## Шаг 2. Модель: Column Preference.php
Эта модель управляет сохранением и извлечением порядка столбцов из базы данных. Создадим ее и изменим в соответствии с кодом:
```
php artisan make:model ColumnPreference
```
```php
use Illuminate\Database\Eloquent\Model;

class ColumnPreference extends Model
{
    protected $fillable = ['admin_id', 'table_name', 'column_order'];
}
```
## Шаг 3. Маршрут:
Определяет маршрут для обработки AJAX-запросов, когда администратор изменяет порядок столбцов.
```php
Route::post('save-column-order', [AdminController::class, 'saveColumnOrder']);
```
## Шаг 4. Контроллер: AdminController.php
Сохраняет или обновляет порядок столбцов для аутентифицированного администратора.
```php
public function saveColumnOrder(Request $request)
{
    $userId = Auth::guard('admin')->id();
    $tableName = $request->table_key;
    if (!$tableName) {
        return response()->json(['status' => 'error', 'message' => 'Table key is required'], 400);
    }
    ColumnPreference::updateOrCreate(
        ['admin_id' => $userId, 'table_name' => $tableName],
        ['column_order' => json_encode($request->column_order)]
    );
    return response()->json(['status' => 'success']);
}
```
## Шаг 5. CategoryController и ProductController
**CategoryController.php**

Извлекает сохраненный порядок столбцов для таблицы категорий и передает его в представление.
```php
public function index()
{
    Session::put('page', 'categories');
    $result = $this->categoryService->categories();
    if ($result['status'] == 'error') {
        return redirect('admin/dashboard')->with('error_message', $result['message']);
    }
    $categoriesSavedOrder = ColumnPreference::where('admin_id', Auth::guard('admin')->id())
        ->where('table_name', 'categories')
        ->value('column_order');
    return view('admin.categories.index', [
        'categories' => $result['categories'],
        'categoriesModule' => $result['categoriesModule'],
        'categoriesSavedOrder' => $categoriesSavedOrder,
    ]);
}
```
**ProductController.php**

Делает то же самое, что и выше, но для таблицы продуктов.
```php
public function index()
{
    Session::put('page', 'products');
    $result = $this->productService->products();
    if ($result['status'] == 'error') {
        return redirect('admin/dashboard')->with('error_message', $result['message']);
    }
    $productsSavedOrder = ColumnPreference::where('admin_id', Auth::guard('admin')->id())
        ->where('table_name', 'products')
        ->value('column_order');
    return view('admin.products.index', [
        'products' => $result['products'],
        'productsModule' => $result['productsModule'],
        'productsSavedOrder' => $productsSavedOrder,
    ]);
}
```
## Шаг 6. Вид: scripts.blade.php (JS и ресурсы)
Включает необходимые библиотеки JS/CSS и обрабатывает инициализацию DataTables, применение сохраненного порядка столбцов и сохранение переупорядоченного макета через AJAX.
```html
<!-- Datatable CSS -->
<link rel="stylesheet" href="https://cdn.datatables.net/1.13.6/css/jquery.dataTables.min.css">
<!-- ColReorder CSS -->
<link rel="stylesheet" href="https://cdn.datatables.net/colreorder/1.6.2/css/colReorder.dataTables.min.css">

<!-- Datatable JS -->
<script src="https://cdn.datatables.net/1.13.6/js/jquery.dataTables.min.js"></script>
<!-- ColReorder JS -->
<script src="https://cdn.datatables.net/colreorder/1.6.2/js/dataTables.colReorder.min.js"></script>
```
```js
<script>
    $(document).ready(function() {
        $("#subadmins").DataTable();

        // Безопасно внедряем PHP данные в JS.
        let categoriesSavedOrder = {!! $categoriesSavedOrder ?? 'null' !!};
        let productsSavedOrder = {!! $productsSavedOrder ?? 'null' !!};

        // Инициализация Categories DataTable
        let categoriesTable = $("#categories").DataTable({
            order: [[0, 'desc']],
            colOrder: {
                order: categoriesSavedOrder
            },
            stateSave: false
        });
        // Управление изменением порядка столбцов для Categories
        categoriesTable.on('column-reorder', function () {
            console.log(categoriesTable);
            let columnOrder = categoriesTable.colOrder.order();
            $.ajax({
                url: "{{ url('admin/save-column-order') }}",
                type: "POST",
                data: {
                    _token: "{{ csrf_token() }}",
                    table_key: 'categories',
                    column_order: columnOrder
                },
                success: function (response) {
                    console.log('Порядок столбцов категорий сохранен: ', response);
                }
            });
        });
        // Инициализация Products DataTable
        let productsTable = $("#products").DataTable({
            order: [[0, 'desc']],
            colOrder: {
                order: productsSavedOrder
            },
            stateSave: false
        });
        // Управление изменением порядка столбцов для Products
        productsTable.on('column-reorder', function () {
            let columnOrder = productsTable.colOrder.order();
            $.ajax({
                url: "{{ url('admin/save-column-order') }}",
                type: "POST",
                data: {
                    _token: "{{ csrf_token() }}",
                    table_key: 'products',
                    column_order: columnOrder
                },
                success: function (response) {
                    console.log('Порядок столбцов продуктов сохранен: ', response);
                }
            });
        });
    });
</script>
```
# Что дальше?
В [следующей части](44.md) мы начнем работать над модулем брендов, который позволит администраторам назначать каждому продукту определенный бренд для лучшей фильтрации и управления.

[Оглавление](../README.md)
